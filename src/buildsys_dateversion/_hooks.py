import os
import logging
import re
import urllib.request
import urllib.error
from datetime import datetime
from contextlib import contextmanager
import importlib

LOG = logging.getLogger("buildsys-dateversion")

if os.getenv("BUILDSYS_DATEVERSION_DEBUG"):
    LOG.setLevel(logging.DEBUG)
    LOG.addHandler(logging.FileHandler(os.getenv("BUILDSYS_DATEVERSION_DEBUG")))

VERSION_PATTERN = re.compile(r"^__version__ *=.*$", flags=re.MULTILINE)


def normalized(version: str):
    # PEP 440 version string normalization.
    #
    # (Not a generic function, just 'good enough' to work on our
    # known strftime templates)
    return ".".join([str(int(x)) for x in version.split(".")])


class DateVersion:
    def __init__(self, config_settings=None):
        self.config_settings: dict = (config_settings or {}).copy()
        self.datetime = datetime.utcnow()
        LOG.debug("operating with datetime = %s", self.datetime)

    @property
    def marker(self) -> str:
        return (
            self.config_settings.get("dateversion-version-marker")
            or "generated by buildsys-dateversion"
        )

    def _find_version_path(self) -> str:
        for dirpath, _, files in os.walk("."):
            for file in files:
                if not file.endswith(".py"):
                    continue

                path = os.path.join(dirpath, file)
                LOG.debug("Checking file %s", path)
                if VERSION_PATTERN.search(open(path).read()):
                    LOG.info("detected __version__ in %s", path)
                    return path

        # TODO: more helpful error string
        raise RuntimeError(
            "Could not locate a file in the source tree defining `__version__`"
        )

    @property
    def version_path(self) -> str:
        if "dateversion-version-path" not in self.config_settings:
            self.config_settings["dateversion-version-path"] = self._find_version_path()
        return self.config_settings["dateversion-version-path"]

    @property
    def build_backend(self):
        if "dateversion-build-backend-object" not in self.config_settings:
            backend_name = (
                self.config_settings.get("dateversion-build-backend")
                or "setuptools.build_meta:__legacy__"
            )

            components = backend_name.split(":")
            module = importlib.import_module(components[0])
            backend = module

            if len(components) == 2:
                backend = getattr(module, components[1])

            LOG.debug("using build backend %s (%s)", backend_name, backend)

            self.config_settings["dateversion-build-backend-object"] = backend

        return self.config_settings["dateversion-build-backend-object"]

    @property
    def index_url(self) -> str:
        out = (
            self.config_settings.get("dateversion-index-url")
            or "https://pypi.org/simple"
        )
        while out.endswith("/"):
            out = out[:-1]
        return out

    @property
    def distribution_name(self) -> str:
        if "dateversion-distribution-name" not in self.config_settings:
            try:
                import tomllib
            except:
                # TODO: implement the hook to add this in requires
                import tomli as tomllib

            with open("pyproject.toml", "rb") as f:
                data = tomllib.load(f)

            LOG.info("Loaded project metadata: %s", data)

            # TODO: nice error message if this fails
            self.config_settings["dateversion-distribution-name"] = data["project"][
                "name"
            ]

        return self.config_settings["dateversion-distribution-name"]

    @property
    def version(self) -> str:
        if "dateversion-distribution-version" not in self.config_settings:
            self.config_settings[
                "dateversion-distribution-version"
            ] = self._get_version()
        return self.config_settings["dateversion-distribution-version"]

    def _get_version(self) -> str:
        formats = [
            "%Y.%m",
            "%Y.%m.%d",
            "%Y.%m.%d.%H",
            "%Y.%m.%d.%H.%M",
        ]

        for format in formats:
            candidate = normalized(self.datetime.strftime(format))
            if not self.version_in_repository(candidate):
                return candidate
            LOG.info(
                "%s-%s is already released, trying next...",
                self.distribution_name,
                candidate,
            )

        # Final fallback
        return normalized(datetime.strftime("%Y.%m.%d.%H.%M.%S"))

    def version_in_repository(self, candidate_version: str) -> bool:
        repo_url = os.path.join(self.index_url, self.distribution_name)

        LOG.info("looking for %s in %s ...", candidate_version, repo_url)

        # TODO: might we need to support custom CA bundles here?
        try:
            with urllib.request.urlopen(repo_url) as response:
                LOG.debug("Response status: %s", response.status)

                body = response.read()
                LOG.debug("Response body: %s", body)

                # Not wanting any real parsing logic here, we'll do a very
                # simple match. There might be some ways this can go wrong.
                return f"{self.distribution_name}-{candidate_version}".encode() in body

        except urllib.error.HTTPError as error:
            if error.getcode() == 404:
                # If repository itself doesn't exist, we'll take that
                # as meaning the distribution has never been released
                # to this index.
                return False
            raise error

    @contextmanager
    def patched_version(self):
        old_version_content = open(self.version_path).read()
        new_version_content = old_version_content

        # Do not patch a version more than once.
        #
        # This is so, for example, if an sdist is prepared and then
        # reused to build a wheel, the version from the sdist 'sticks'
        # rather than being recalculated and potentially changing.
        if self.marker not in old_version_content:
            new_version_content = VERSION_PATTERN.sub(
                f"__version__ = {repr(self.version)}  # {self.marker}",
                old_version_content,
            )
        try:
            # TODO: find a better way which doesn't require patching
            # in place.
            if new_version_content != old_version_content:
                open(self.version_path, "w").write(new_version_content)
            yield
        finally:
            if new_version_content != old_version_content:
                # TODO: restore previous mtime?
                open(self.version_path, "w").write(old_version_content)

    def delegate_build_wheel(
        self, wheel_directory, config_settings, metadata_directory
    ):
        return self.build_backend.build_wheel(
            wheel_directory,
            config_settings=config_settings,
            metadata_directory=metadata_directory,
        )

    def delegate_build_sdist(self, sdist_directory, config_settings):
        return self.build_backend.build_sdist(
            sdist_directory=sdist_directory, config_settings=config_settings
        )

    def delegate_build_editable(
        self, wheel_directory, config_settings, metadata_directory
    ):
        return self.build_backend.build_editable(
            wheel_directory,
            config_settings=config_settings,
            metadata_directory=metadata_directory,
        )


def build_wheel(wheel_directory, config_settings=None, metadata_directory=None):
    helper = DateVersion(config_settings=config_settings)
    with helper.patched_version():
        return helper.delegate_build_wheel(
            wheel_directory,
            config_settings=config_settings,
            metadata_directory=metadata_directory,
        )


def build_sdist(sdist_directory, config_settings=None):
    helper = DateVersion(config_settings=config_settings)
    with helper.patched_version():
        return helper.delegate_build_sdist(sdist_directory, config_settings)


# FIXME: I only want to define build_editable here if the delegate backend
# also defines that. But, how can I know which delegate is being used
# at import time?
#
# - Hooks aren't being invoked yet, so there's no `config_settings`
#
# - Although PEP 517 says hooks are invoked with the working directory
#   being equal to a project's root, this only speaks of the environment
#   at hook execution time and not at import time. So we can't guarantee
#   the working directory at this point, meaning we can't reliably locate
#   pyproject.toml to look up settings there.
#
# We'll just define a build_editable always, and expect an error if
# the delegate backend doesn't have it.
def build_editable(wheel_directory, config_settings=None, metadata_directory=None):
    helper = DateVersion(config_settings=config_settings)
    # Should there be version patching for editable mode or not??
    with helper.patched_version():
        return helper.delegate_build_editable(
            wheel_directory, config_settings, metadata_directory
        )


# TODO: is it necessary to implement prepare_metadata_for_build_wheel
# as well? Noting that PEP 517 says build_wheel must respect metadata
# earlier prepared by prepare_metadata_for_build_wheel (if any), so in
# that case, it'd be too late to patch the version.
